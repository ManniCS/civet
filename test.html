<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

	/** Setting up variables. **/
	var w = 960,
	    h = 500,
	    force;
	console.log("hi there!1");
	var svg = d3.select("body").append("svg")
	    .attr("height", h)
	    .attr("width", w);

	/* Declare variables that will be used globally later in the script. */
	var force; //variable for force layout
	var l, n;  //Calculate the number of links and nodes on the string. 
	var nodes2, links2; //Set of nodes and links in the original dataset
	var restarted; //Variable to indicated whether the layout has been restarted yet

	/* The set of all d3 elements on the screen 
	 (and data bound to them.) */
	var links = svg.selectAll("line"),
		nodes = svg.selectAll("circle");

	/* Define the dataset */
	var dataset = {}; //the dataset of reduced nodes
	var dataset2 = {}; //the primary dataset

	/* Load the datasets from their respective files. */
	// d3.json("graph._json", function(error, json) { 
	// 	dataset = json;
	// 	console.log(json);
	// }); 

	// d3.json("graph.json", function(error, json) { 
	// 	dataset2 = json;
	// 	console.log(json);
	// }); 

	dataset = {
	"nodes": [
			{ "name": "Jack", 
			  "children": ["John"]
			},{ 
			  "name": "John",
			  "children": ["Cynthia", "Portbello", "James"]
			},{
			  "name": "Cynthia", 
			  "children": []
			},{
			  "name": "Portbello",
			  "children": []
			},{
			  "name": "James",
			  "children": []
			}
		   ], 
	"links": [
			{"source": 0, "target": 1},
		    {"source": 1, "target": 2}, 
		    {"source": 1, "target": 3}, 
		    {"source": 1, "target": 4}
		   ]
	};

	dataset2 = { 
	"nodes": [
			{ "name": "Jack", 
			  "children": ["John"]
			},{ 
			  "name": "John",
			  "children": ["Cynthia", "Portbello", "James"]
			},{
			  "name": "Cynthia", 
			  "children": []
			},{
			  "name": "Portbello",
			  "children": []
			},{
			  "name": "James",
			  "children": []
			}
		   ], 
	"links": [
			{"source": 0, "target": 1},
		    {"source": 1, "target": 2}, 
		    {"source": 1, "target": 3}, 
		    {"source": 1, "target": 4}
		   ]
	};

	/* A synchronous loading of json data, causing some errors, 
	   unless entire force layout is initialized within here. */
	// d3.json("dataset.json", function (error, json) { 
	// 	/* Here */
	// 	dataset = json;

	// 	force = d3.layout.force()
	// 					 .nodes(dataset.nodes)
	// 					 .links(dataset.links)
	// 					 .size([w, h])
	// 					 .on("tick", tick)
	// 					 .start();

	// 	var links = svg.selectAll("line")
	//         .data(dataset.links)
	//         .enter()
	//         .append("line")
	//         .style("stroke", "#ccc")
	//         .style("stroke-width", 1);

	//     var nodes = svg.selectAll("circle")
	//         .data(dataset.nodes)
	//         .enter()
	//         .append("circle")
	//         .attr("r", 10)
	//         .call(force.drag);

	// });

	/* Inject a 3 second delay before running the code for the main functioning of the program
	   to allow the browser to load the information from the local files into the javascript 
	   variables for the graph information.*This is janky. Find a way to fix it.* */
	sleep(10, main);

	/** Define functions for use in the script. **/

	/* Returns an array of the objects corresponding 
	   to a particular node's children, accepting a s
	   list of their names. */
	var arrayOfChildren = function arrayOfChildren(children) {
		var array = [];
		for (var i = 0; i < dataset2.nodes.length; i++) { 
			for (var j = 0; j < children.length; j++) { //consider replacing with jQuery .contains(?)
				if (dataset2.nodes[i].name == children[j]) 
					array.push(dataset2.nodes[i]);
			}
		}
		return array;
	}

	/* Returns an array of the objects corresponding to a particular 
	   node's child links, accepting the node obj, and a list of their 
	   names. */
	var arrayOfChildLinks = function arrayOfChildLinks (source, children) { 
		var array = [];
		for (var i = 0; i < dataset2.links.length; i++) { 
			for (var j = 0; j < children.length; j++) { 
				/* Cannot be handled as links in the array tracked by the 
				   force layout as target and source are not populated with 
				   their corresponding objects. */
				var sourceName = dataset2.nodes[dataset2.links[i].source].name;
				var targetName = dataset2.nodes[dataset2.links[i].target].name;
				if (sourceName == source.name && targetName == children[j]) { 
						console.log(dataset2.links[i]);
						array.push(dataset2.links[i]);
				}
			}
		}
		return array;
	}

	/* Returns the child-object from the original 
	   dataset corresponding to a particular name. */
	var childWithName = function childWithName(name) { 
		for (var i = 0; i < nodes2.length; i++) { 
			if (nodes2[i].name == name) 
				return dataset2.nodes[i];
		}
		return false;
	}

	/* Returns the force-layout tracked object 
	   corresponding to a particular name. */
	var forcedChildWithName = function forcedChildWithName(name) { 
		for (var i = 0; i < dataset.nodes.length; i++) { 
			if (dataset.nodes[i].name == name) 
				return dataset.nodes[i];
		} 
		return false;
	}

	/* Returns the equivalent degree value in radians. */
	var degToRad = function degToRad (degrees) { 
		return degrees * (Math.PI / 180);
	}

	/* Restarts the force layout based on the nodes and links it tracks 
       and binds those nodes + links to the screen. */
	var restart = function restart() {
	  console.log("restarting!");
	  console.log(force.links());
	  links = links.data(force.links(), function(d) { return d.source.name + d.target.name });
	  links.enter().insert("line", ".node")
	  			   .attr("id", function (d) { return d.source.name + d.target.name })
	  			   .style("stroke", "#ccc")
				   .style("stroke-width", 1);
	  links.exit().remove();

	  nodes = nodes.data(force.nodes(), function(d) { return d.name });
	  nodes.enter().append("circle")
	  			   .attr("r", 10)
	  			   .attr("id", function(d) { return d.name })
	  			   .attr("class", "node")
	  			   .on("click", click)
	  			   .call(force.drag);
	  nodes.exit().remove();

	  force.start();
	}

	/* Returns the index of the node with the given 
	   name.  */
	var indexOfNode = function indexOfNode (name) { 
		for (var i = 0; i < dataset.nodes.length; i++) { 
			if (dataset.nodes[i].name == name)
				return i;
		}
		return -1;
	}

	/* Returns the index of the link matching the 
	   given names of the source and target. */
	var indexOfLink = function indexOfLink (source, target) { 
		for (var i = 0; i < dataset.links.length; i++) { 
			if (dataset.links[i].source.name == source &&
				 dataset.links[i].target.name == target)
				return i;
		}
	}

	/* Updates all of the links and nodes associated with a 
	   force directed layout based on the properties computed 
	   for these nodes + links by the layout. */
	var tick = function tick() {
		links.attr("x1", function(d) { return d.source.x; })
		     .attr("y1", function(d) { return d.source.y; })
		     .attr("x2", function(d) { return d.target.x; })
		     .attr("y2", function(d) { return d.target.y; });

		nodes.attr("cx", function(d) { return d.x; })
		     .attr("cy", function(d) { return d.y; });
	}

	/* Recursively call collapse children on all of source's expanded children */
	var collapseChildren = function collapseChildren(source_master, source, duration) { 
		/* Base case */
		if (!source.children) return;
		console.log("Hi! I am" + source.name);
		console.log("I have children!");
		console.log("they are: ");
		console.log(source.children);

		/* Calculate the new number of links that will be on the screen */
		var newL = l - source.children.length;
		var newN = n - source.children.length;

		/* A boolean to indicate whether the layout has been 
		   restarted */
		restarted = false; 

		/* Select the appropriate DOM elements one by 
		   one and collapse them */
		for (var i = 0; i < source.children.length; i++) { 
			/* Collapse the child nodes */
			svg.select("#" + source.children[i])
			   .transition()
			   .duration(duration)	
			   .attr("cx", source_master.x)
			   .attr("cy", source_master.y)
			   .attr("r", 1e-6)
			   // .style("opacity", 0.8)
			   .each("end", function () { 
			   	  	/* Remove child node from page */
					this.remove();

				   	/* Calculate the new number of nodes and links 
				      on the screen */
					l = svg.selectAll("line")[0].length;
			       	n = svg.selectAll("circle")[0].length;

			      	/* If all of the child links and nodes have been removed
			      	   restart the layout */
			      	if (newL <= l && newN <= n && !restarted) {
			      		restarted = true;
			      		restart();
			      	}
			   });

			/* Remove the child node from the set of nodes 
			   tracked by the force layout. */
			force.nodes().splice(indexOfNode(source.children[i]), 1);

			/* Collapse the child link */
			svg.select("#" + source.name + source.children[i])
				   .transition()
				   .duration(duration)
				   .attr("x1", source_master.x)
				   .attr("y1", source_master.y)
			       .attr("x2", source_master.x)
			       .attr("y2", source_master.y)
			       // .style("opacity", 0)
			   	   .each("end", function () { 
			   	  	 /* Remove child node from page */
					 this.remove();

				   	 /* Calculate the new number of nodes and links 
				       on the screen */
					 l = svg.selectAll("line")[0].length;
			       	 n = svg.selectAll("circle")[0].length;

			      	 /* If all of the child links and nodes have been removed
			      	    restart the layout */
			      	 if (newL <= l && newN <= n && !restarted) {
			      	 	restarted = true;	
			      	 	restart();
			      	 }
			   	   });

			/* Remove the link from the set of links 
			   tracked by the force layout. */
			force.links().splice(indexOfLink(source.name, source.children[i]), 1);

		}

		/* Recursively call collapseChildren on all the expanded children of a node.*/
		for (var i = 0; i < source.children.length; i++) { 
			console.log("About to call recursively.");
			console.log("These are my children here: ");
			console.log(source.children);
			console.log("Here is my forced child");
			console.log(childWithName(source.children[i]));
			collapseChildren(source_master, childWithName(source.children[i]), duration);
		}

		/* Set the children field to null, to indicated non-expanded children.*/
		source._children = source.children;
		source.children = null; 
	}

	/* Expand children; at this point: one level at a time. */
	var expandChildren = function expandChildren(source, duration) { 
		/* Calculate the new number of links that will be on the screen 
		   before layout-refresh */
		var newL = l;
		var newN = n;

		/* Initialize an array of all children who should be added to 
		   the nodes + links in the force layout after the nodes are 
		   drawn and removed from the page */
		var childNodes = [];
		var childLinks = [];

		console.log("mychildren have collapsed!");
		console.log(source);
		/* Calculate positioning information for expanding nodes */
		var r = 50;
		var theta = 2 * Math.PI / source._children.length;

		restarted = false;

		/* Draw the children on the screen, on top of their parent */
	    var nodeEnter = svg.selectAll("circle")
					    .data(arrayOfChildren(source._children), function (d) {return d.name})
						.enter()
						.append("circle")
						.attr("r", 1e-6)
					    .attr("id", function(d) { return d.name })
					    .attr("class", "node")
					    .attr("cx", source.x)
					    .attr("cy", source.y)
					    .style("opacity", 1)
						.on("click", click)
						.call(force.drag);

		/* Draw links beginning and ending at their source. */
		var linkEnter = svg.selectAll("line")
						.data(arrayOfChildLinks(source, source._children), function (d) { 
							/* d3 is doing something weird here where some of the d.target/source attrs 
							   are objects and some are numbers (as per the array returned by the array 
							   ofChildLinks method). This if statement checks that dataset2.nodes[d.source/target]
							   is defined. */
							if (dataset2.nodes[d.source] && dataset2.nodes[d.target].name)
								return dataset2.nodes[d.source].name + dataset2.nodes[d.target].name;
						})
						.enter()
						.insert("line", ".node")
						.attr("r", 10)
				        .style("stroke", "#ccc")
				        .style("stroke-width", 1)
						.attr("id", function (d) { return dataset2.nodes[d.source].name + dataset2.nodes[d.target].name })
						.attr("x1", source.x)
						.attr("y1", source.y)
						.attr("x2", source.x)
						.attr("y2", source.y);

		/* Expand nodes & links one by one */
		for (var i = 0; i < source._children.length; i++) {
			console.log("children here");
			console.log(source._children); 

			/* Child to be added */
		    var child = childWithName(source._children[i]);

		    /* Expand child node */
			svg.select("#" + source._children[i])
			    .transition()
				.duration(duration)
				.attr("r", 10)
				.attr("cx", function () {
					child.x = source.x + r * Math.sin(theta * i);
					return child.px = source.x + r * Math.sin(theta * i);
				})
				.attr("cy", function () { 
					child.y = source.y + r * Math.cos(theta * i);
					child.py = child.y;
					/* Add the child node and link to the child nodes and links. */
		  				childNodes.push(child);
					childLinks.push({source: source, target: child});

				 	return source.y + r * Math.cos(theta * i);
				})	
				.style("opacity", 1)
				.each("end", function () { 
					/* Remove it from the screen */
					this.remove();

					/* Calculate the new number of nodes and links 
					   on the screen */
					l = svg.selectAll("line")[0].length;
			      	n = svg.selectAll("circle")[0].length;

			      	/* If all of the child links and nodes have been removed
			          restart the layout */
			      	if (newL == l && newN == n && !restarted) {
			      		console.log("here!");
			      		restarted = true;
			      		/* Add all data for added child nodes to set 
			      		   tracked by the force layout */
			      		for (var i = 0; i < childNodes.length; i++) 
							force.nodes().push(childNodes[i]);

			      		/* Add all data for add child links to set 
			      		   tracked by the force layout */
			      		for (var i = 0; i < childLinks.length; i++)
			      			force.links().push(childLinks[i])

			      		/* Restart the force layout */
			      		restart();
			      	}
				});

			/* Expand link */
			svg.select("#" + source.name + source._children[i])
			   .transition()
			   .duration(duration)
			   .attr("x2", function () { return source.x + r * Math.sin(theta * i) })
			   .attr("y2", function () { 
			   	/* Link has already been added (to the set tracked by the force 
			   	   layout when adding nodes above) */
			   	return source.y + r * Math.cos(theta * i);
			   })
			   .each("end", function () { 
			   	 /* Remove this from the screen. Adding to the force layout (etc) 
			   	    has already been done above, in animating the nodes. */
			   	 this.remove();

		   	 	 /* Calculate the new number of nodes and links 
				    on the screen */
				 l = svg.selectAll("line")[0].length;
		      	 n = svg.selectAll("circle")[0].length;

			   	 if (newL == l && newN == n && !restarted) {
			   	 	restarted = true;
			      		/* Add all data for added child nodes to set 
			      		   tracked by the force layout */
			      		for (var i = 0; i < childNodes.length; i++) 
							force.nodes().push(childNodes[i]);

			      		/* Add all data for add child links to set 
			      		   tracked by the force layout */
			      		for (var i = 0; i < childLinks.length; i++)
			      			force.links().push(childLinks[i])

			      		/* Restart the force layout */
			      		restart();
			   	 }
			   });
		}
			/* Add the node and link to the arrays used to join this data 
			   to the set of nodes and links tracked by the force layout */
				// childNodes.push(childWithName(source._children[i]));
			// childLinks.push({source: source, target: childWithName(source._children[i])});

		source.children = source._children; 
	}

	/* Define what happens to a node on a click event */
	var click = function click(source) { 
		console.log("Hi, my name is " + source.name + "!");
		/* Select a duration. */
		var duration = d3.event && d3.event.altKey ? 5000 : 500;

		/* Calculate the number of links and nodes on the screen. */
		l = svg.selectAll("line")[0].length;
		n = svg.selectAll("circle")[0].length;

		/* Collapse children. */
		if (source.children && source.children.length > 0) { 
			collapseChildren(source, source, duration);
		/* Expand children */
		} else if (source._children) { //If children collapsed
			expandChildren(source, duration);
		} else { 
			console.log(console.log("no children!"));
		}
		console.log(source.name);
		console.log(source.children);
	};

	function main() { 
		console.log("just before!");
	    nodes2 = dataset2.nodes; 
		links2 = dataset2.links;

		/* Start the force layout */
		force = d3.layout.force()
							 .nodes(dataset.nodes)
							 .links(dataset.links)
							 .size([w, h])
		                     .linkDistance([50])
		                     .charge([-100])   
							 .on("tick", tick)
							 .start();

		/* Put all the links on the canvas */
		links = svg.selectAll("line")
	        .data(dataset.links, function (d) { return d.source.name + d.target.name })
	        .enter() 
	        .insert("line", ".node")
	        .style("stroke", "#ccc")
	        .style("stroke-width", 1)
	        .attr("id", function (d) { return d.source.name + d.target.name  } );

	    /* Put all the nodes on the canvas */
		nodes = svg.selectAll("circle")
	        .data(dataset.nodes, function (d) {return d.name})
	        .enter()
	        .append("circle")
	        .attr("r", 10)
	        .attr("id", function(d) {return d.name})
	        .attr("class", "node")
	        .on("click", click)
	        .call(force.drag);

	    /* Calculate the number of links and nodes 
	       on the string. */
	    l = links[0].length;
	   	n = nodes[0].length;
	}

	/* Sleep function */
	function sleep(millis, callback) { 
		setTimeout(function() 
			{ callback(); }, 
		millis);
	}

</script>
</body>