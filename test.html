<!DOCTYPE html>
<meta charset="utf-8">
<link type="text/css" rel="stylesheet" href="style.css"/>
<style type="text/css">

body { 
	  background: url(texture-noise.png);
	  overflow: hidden;
	  margin: 0;
	  font-size: 14px;
	  font-family: "Helvetica Neue", Helvetica;
}

node:hover {
  color: #666;
}

.node {
  cursor: pointer;
  stroke: #3182bd;
  stroke-width: 3px;
}

.node text {
  font-size: 11px;
}

path.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>
<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

	/** Setting up variables. **/
	var w = 1500,
	    h = 750,
	    colorscheme1 = true,
	    colorscheme2 = colorscheme1 ? false : true,
	    node_radius = colorscheme1 ? 15 : colorscheme2 ? 10 : 10, 
	    refX = colorscheme1 ? 25 : colorscheme2 ? 23 : 23, 
	    refY = colorscheme1 ? 0 : colorscheme2 ? 0 : 0, 
	    markerHeight = colorscheme1 ? 11 : colorscheme2 ? 8 : 8, 
	    markerWidth = colorscheme1 ? 11 : colorscheme2 ? 8 : 8, 
	    path = colorscheme1 ? "M0,-3L10,0L0,3" : colorscheme2 ? "M0,-4L10,0L0,4" : "M0,-4L10,0L0,4", //path for marker
	    single_click_timeout = 500;

	// console.log("hi there!1");
	var svg = d3.select("body").append("svg")
	    .attr("height", h)
	    .attr("width", w);

	/* Declare variables that will be used globally later in the script. */
	var force, //variable for force layout
	    l, n, //Calculate the number of links and nodes on the string. 
        nodes2, links2, //Set of nodes and links in the original dataset
	    restarted, //Variable to indicated whether the layout has been restarted yet
	    last_click = (new Date).getTime(); //Variable to record the last_click on the dom

	/* The set of all d3 elements on the screen 
	 (and data bound to them.) */
	var links = svg.selectAll("line"),
		nodes = svg.selectAll("circle"),
		text = svg.selectAll("text"); //labels

	/* Define the dataset */
	var dataset = {}; //the dataset of reduced nodes
	var dataset2 = {}; //the primary dataset

	/* Load the datasets from their respective files. */
	// d3.json("graph_tree._json", function(error, json) { 
	// 	dataset = json;
	// 	// console.log(json);
	// }); 

	// d3.json("graph.json", function(error, json) { 
	// 	dataset2 = json;
	// 	// console.log(json);
	// }); 

	// dataset = {
	// "nodes": [
	// 		{ "name": "Jack", 
	// 		  "children": ["John"]
	// 		},{ 
	// 		  "name": "John",
	// 		  "children": ["Cynthia", "Portbello", "James"]
	// 		},{
	// 		  "name": "Cynthia", 
	// 		  "children": []
	// 		},{
	// 		  "name": "Portbello",
	// 		  "children": []
	// 		},{
	// 		  "name": "James",
	// 		  "children": []
	// 		}
	// 	   ], 
	// "links": [
	// 		{"source": 0, "target": 1},
	// 	    {"source": 1, "target": 2}, 
	// 	    {"source": 1, "target": 3}, 
	// 	    {"source": 1, "target": 4}
	// 	   ]
	// };

	// dataset2 = { 
	// "nodes": [
	// 		{ "name": "Jack", 
	// 		  "children": ["John"]
	// 		},{ 
	// 		  "name": "John",
	// 		  "children": ["Cynthia", "Portbello", "James"]
	// 		},{
	// 		  "name": "Cynthia", 
	// 		  "children": []
	// 		},{
	// 		  "name": "Portbello",
	// 		  "children": []
	// 		},{
	// 		  "name": "James",
	// 		  "children": []
	// 		}
	// 	   ], 
	// "links": [
	// 		{"source": 0, "target": 1},
	// 	    {"source": 1, "target": 2}, 
	// 	    {"source": 1, "target": 3}, 
	// 	    {"source": 1, "target": 4}
	// 	   ]
	// };

	// dataset ={"nodes": [
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STUser", "children": ["PDUserProfile", "STUserAuthorization", "ECDataHelper", "PDUser"]}, 
	// 			{"parents": ["STUser"], "name": "PDUserProfile", "children": []}, 
	// 			{"parents": ["STUser"], "name": "STUserAuthorization", "children": []}, 
	// 			{"parents": ["STUser"], "name": "ECDataHelper", "children": []}, 
	// 			{"parents": ["STUser"], "name": "PDUser", "children": []}, 
	// 			{"parents": [], "name": "STDisplayManager_iPhone", "children": ["STViewControllerFactoryCollection", "STUser", "STLoginViewController_iPhone", "STConstants"]}, 
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STViewControllerFactoryCollection", "children": ["STInitializationViewControllerFactory", "STGroupViewControllerFactory", "STMessageViewControllerFactory"]}, 
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STLoginViewController_iPhone", "children": ["STNavigationController", "STLoginViewModel", "STViewController"]}, 
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STConstants", "children": []}, 
	// 			{"parents": ["STViewControllerFactoryCollection"], "name": "STInitializationViewControllerFactory", "children": []}, 
	// 			{"parents": ["STViewControllerFactoryCollection"], "name": "STGroupViewControllerFactory", "children": []}, 
	// 			{"parents": ["STViewControllerFactoryCollection"], "name": "STMessageViewControllerFactory", "children": []}, 
	// 			{"parents": ["STLoginViewController_iPhone"], "name": "STNavigationController", "children": []}, 
	// 			{"parents": ["STLoginViewController_iPhone"], "name": "STLoginViewModel", "children": []}, 
	// 			{"parents": ["STLoginViewController_iPhone"], "name": "STViewController", "children": []}], 
	// 			"links": [
	// 			{"source": 0, "target": 1}, 
	// 			{"source": 0, "target": 2}, 
	// 			{"source": 0, "target": 3}, 
	// 			{"source": 0, "target": 4}, 
	// 			{"source": 5, "target": 6}, 
	// 			{"source": 5, "target": 0}, 
	// 			{"source": 5, "target": 7}, 
	// 			{"source": 5, "target": 8}, 
	// 			{"source": 6, "target": 9}, 
	// 			{"source": 6, "target": 10}, 
	// 			{"source": 6, "target": 11}, 
	// 			{"source": 7, "target": 12}, 
	// 			{"source": 7, "target": 13}, 
	// 			{"source": 7, "target": 14}]};

	// dataset2 = {"nodes": [
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STUser", "children": ["PDUserProfile", "STUserAuthorization", "ECDataHelper", "PDUser"]}, 
	// 			{"parents": ["STUser"], "name": "PDUserProfile", "children": []}, 
	// 			{"parents": ["STUser"], "name": "STUserAuthorization", "children": []}, 
	// 			{"parents": ["STUser"], "name": "ECDataHelper", "children": []}, 
	// 			{"parents": ["STUser"], "name": "PDUser", "children": []}, 
	// 			{"parents": [], "name": "STDisplayManager_iPhone", "children": ["STViewControllerFactoryCollection", "STUser", "STLoginViewController_iPhone", "STConstants"]}, 
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STViewControllerFactoryCollection", "children": ["STInitializationViewControllerFactory", "STGroupViewControllerFactory", "STMessageViewControllerFactory"]}, 
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STLoginViewController_iPhone", "children": ["STNavigationController", "STLoginViewModel", "STViewController"]}, 
	// 			{"parents": ["STDisplayManager_iPhone"], "name": "STConstants", "children": []}, 
	// 			{"parents": ["STViewControllerFactoryCollection"], "name": "STInitializationViewControllerFactory", "children": []}, 
	// 			{"parents": ["STViewControllerFactoryCollection"], "name": "STGroupViewControllerFactory", "children": []}, 
	// 			{"parents": ["STViewControllerFactoryCollection"], "name": "STMessageViewControllerFactory", "children": []}, 
	// 			{"parents": ["STLoginViewController_iPhone"], "name": "STNavigationController", "children": []}, 
	// 			{"parents": ["STLoginViewController_iPhone"], "name": "STLoginViewModel", "children": []}, 
	// 			{"parents": ["STLoginViewController_iPhone"], "name": "STViewController", "children": []}], 
	// 			"links": [
	// 			{"source": 0, "target": 1}, 
	// 			{"source": 0, "target": 2}, 
	// 			{"source": 0, "target": 3}, 
	// 			{"source": 0, "target": 4}, 
	// 			{"source": 5, "target": 6}, 
	// 			{"source": 5, "target": 0}, 
	// 			{"source": 5, "target": 7}, 
	// 			{"source": 5, "target": 8}, 
	// 			{"source": 6, "target": 9}, 
	// 			{"source": 6, "target": 10}, 
	// 			{"source": 6, "target": 11}, 
	// 			{"source": 7, "target": 12}, 
	// 			{"source": 7, "target": 13}, 
	// 			{"source": 7, "target": 14}]};

	dataset = {"nodes": [
				{"parents": ["STViewController"], "name": "STDisplayManager_iPhone", "children": ["STViewControllerFactoryCollection", "STUser", "STConstants", "STLoginViewController_iPhone"]},
				{"parents": ["STDisplayManager_iPhone", "STViewController"], "name": "STViewControllerFactoryCollection", "children": ["STGroupViewControllerFactory", "STMessageViewControllerFactory", "STInitializationViewControllerFactory"]},
				{"parents": ["STDisplayManager_iPhone", "STSaveProfileOperation", "STRemoveGroupMembersOperation", "STChangeColleagueBlockStatusOperation"], "name": "STUser", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STConstants", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STLoginViewController_iPhone", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STGroupViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STMessageViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STInitializationViewControllerFactory", "children": []
				},
				{"parents": [], "name": "STViewController", "children": ["STDisplayManager_iPhone", "STViewControllerFactoryCollection"]},
				{"parents": [], "name": "STSaveProfileOperation", "children": ["STUser"]},
				{"parents": [], "name": "STRemoveGroupMembersOperation", "children": ["STUser"]},
				{"parents": [], "name": "STChangeColleagueBlockStatusOperation", "children": ["STUser"]}],
				"links": [
				{"source": 0, "target": 1},
				{"source": 0, "target": 2},
				{"source": 0, "target": 3},
				{"source": 0, "target": 4},
				{"source": 1, "target": 5},
				{"source": 1, "target": 6},
				{"source": 1, "target": 7},
				{"source": 8, "target": 0},
				{"source": 8, "target": 1},
				{"source": 9, "target": 2},
				{"source": 10, "target": 2},
				{"source": 11, "target": 2}]};

	dataset2 = {"nodes": [
				{"parents": ["STViewController"], "name": "STDisplayManager_iPhone", "children": ["STViewControllerFactoryCollection", "STUser", "STConstants", "STLoginViewController_iPhone"]},
				{"parents": ["STDisplayManager_iPhone", "STViewController"], "name": "STViewControllerFactoryCollection", "children": ["STGroupViewControllerFactory", "STMessageViewControllerFactory", "STInitializationViewControllerFactory"]},
				{"parents": ["STDisplayManager_iPhone", "STSaveProfileOperation", "STRemoveGroupMembersOperation", "STChangeColleagueBlockStatusOperation"], "name": "STUser", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STConstants", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STLoginViewController_iPhone", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STGroupViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STMessageViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STInitializationViewControllerFactory", "children": []
				},
				{"parents": [], "name": "STViewController", "children": ["STDisplayManager_iPhone", "STViewControllerFactoryCollection"]},
				{"parents": [], "name": "STSaveProfileOperation", "children": ["STUser"]},
				{"parents": [], "name": "STRemoveGroupMembersOperation", "children": ["STUser"]},
				{"parents": [], "name": "STChangeColleagueBlockStatusOperation", "children": ["STUser"]}],
				"links": [
				{"source": 0, "target": 1},
				{"source": 0, "target": 2},
				{"source": 0, "target": 3},
				{"source": 0, "target": 4},
				{"source": 1, "target": 5},
				{"source": 1, "target": 6},
				{"source": 1, "target": 7},
				{"source": 8, "target": 0},
				{"source": 8, "target": 1},
				{"source": 9, "target": 2},
				{"source": 10, "target": 2},
				{"source": 11, "target": 2}]};

	/* Asynchronous loading of json data, causing some errors, 
	   unless entire force layout is initialized within here. */
	// d3.json("dataset.json", function (error, json) { 
	// 	/* Here */
	// 	dataset = json;

	// 	force = d3.layout.force()
	// 					 .nodes(dataset.nodes)
	// 					 .links(dataset.links)
	// 					 .size([w, h])
	// 					 .on("tick", tick)
	// 					 .start();

	// 	var links = svg.selectAll("line")
	//         .data(dataset.links)
	//         .enter()
	//         .append("line")
	//         .style("stroke", "#ccc")
	//         .style("stroke-width", 1);

	//     var nodes = svg.selectAll("circle")
	//         .data(dataset.nodes)
	//         .enter()
	//         .append("circle")
	//         .attr("r", node_radius)
	//         .call(force.drag);

	// });

	/* Inject a 3 second delay before running the code for the main functioning of the program
	   to allow the browser to load the information from the local files into the javascript 
	   variables for the graph information.*This is janky. Find a way to fix it.* */
	sleep(10, main);

	/** Define functions for use in the script. **/

	/* Returns an array of the objects corresponding 
	   to a particular node's children, accepting a 
	   list of their names. */
	var arrayOfChildren = function arrayOfChildren(children) {
		var array = [];
		for (var i = 0; i < dataset2.nodes.length; i++) { 
			for (var j = 0; j < children.length; j++) { //consider replacing with jQuery .contains(?)
				if (dataset2.nodes[i].name == children[j]) 
					array.push(dataset2.nodes[i]);
			}
		}
		return array;
	}

	/* Returns an array of the objects corresponding to a particular 
	   node's child links, accepting the node obj, and a list of their 
	   names. */
	var arrayOfChildLinks = function arrayOfChildLinks (source, children) { 
		var array = [];
		for (var i = 0; i < dataset2.links.length; i++) { 
			for (var j = 0; j < children.length; j++) { 
				/* Cannot be handled as links in the array tracked by the 
				   force layout as target and source are not populated with 
				   their corresponding objects. */
				var sourceName = dataset2.nodes[dataset2.links[i].source].name;
				var targetName = dataset2.nodes[dataset2.links[i].target].name;
				if (sourceName == source.name && targetName == children[j]) { 
						// console.log(dataset2.links[i]);
						array.push(dataset2.links[i]);
				}
			}
		}
		return array;
	}

	/* Returns the child-object from the original 
	   dataset corresponding to a particular name. */
	var childWithName = function childWithName(name) { 
		for (var i = 0; i < nodes2.length; i++) { 
			if (nodes2[i].name == name) { 
				// console.log("Found: ");
				// console.log(dataset2.nodes[i]);
				return dataset2.nodes[i];
			}
		}
		// console.log("childWithName returning false!");
		return false;
	}

	/* Returns the force-layout tracked object 
	   corresponding to a particular name. */
	var forcedChildWithName = function forcedChildWithName(name) { 
		for (var i = 0; i < dataset.nodes.length; i++) { 
			if (dataset.nodes[i].name == name) {
				// console.log("Found " + dataset.nodes[i].name + "!")
				return dataset.nodes[i];
			}
		} 
		// console.log("returning false!");
		return false;
	}

	/* Returns the equivalent degree value in radians. */
	var degToRad = function degToRad (degrees) { 
		return degrees * (Math.PI / 180);
	}

	/* Restarts the force layout based on the nodes and links it tracks 
       and binds those nodes + links to the screen. */
	var restart = function restart() {
	  // console.log("restarting!");
	  // console.log(force.links());
	  links = links.data(force.links(), function(d) { return d.source.name + d.target.name });
	  links.enter().insert("line", ".node")
	  			   .attr("id", function (d) { return d.source.name + d.target.name })
	  			   .style("stroke", "#ccc")
				   .style("stroke-width", 1)
				   .attr("marker-end", "url(#Triangle)");
	  links.exit().remove();

	  nodes = nodes.data(force.nodes(), function(d) { return d.name });
	  nodes.enter().append("circle")
	  			   .style("fill", color)
	  			   .attr("r", node_radius)
	  			   .attr("id", function(d) { return d.name })
	  			   .attr("class", "node")
	  			   .on("click", click)
	  			   .call(force.drag);
	  nodes.exit().remove();

	  text = text.data(force.nodes(), function (d) { return d.name + "t"});
	  text.enter().append("text")
	  			  .attr("x", -5)
				  .attr("y", "2em")
				  .attr("id", function (d) { return d.name + "t" })
				  .text(function(d) { return d.name; });

	  force.start();
	  
	  /* Unfix the nodes */
	  for (var i = 0; i < force.nodes().length; i++) { 
	  	  force.nodes()[i].fixed = false;
	  }
	}

	/* Returns the index of the node with the given 
	   name.  */
	var indexOfNode = function indexOfNode (name) { 
		for (var i = 0; i < dataset.nodes.length; i++) { 
			if (dataset.nodes[i].name == name)
				return i;
		}
		return -1;
	}

	/* Returns the index of the link matching the 
	   given names of the source and target. */
	var indexOfLink = function indexOfLink (source, target) { 
		for (var i = 0; i < dataset.links.length; i++) { 
			if (dataset.links[i].source.name == source &&
				 dataset.links[i].target.name == target)
				return i;
		}
	}

	/* Updates all of the links and nodes associated with a 
	   force directed layout based on the properties computed 
	   for these nodes + links by the layout. */
	var tick = function tick() {
		links.attr("x1", function(d) { return d.source.x; })
		     .attr("y1", function(d) { return d.source.y; })
		     .attr("x2", function(d) { return d.target.x; })
		     .attr("y2", function(d) { return d.target.y; });

		nodes.attr("cx", function(d) { return d.x; })
		     .attr("cy", function(d) { return d.y; });

		text.attr("transform", transform);
	}

	/* */
	var transform = function (d) {
		return "translate(" + d.x + "," + d.y +")";
	}

	/* Recursively call collapse children on all of source's expanded children */
	var collapseChildren = function collapseChildren(source_master, source, duration, depth) { 
		/* Base case */
		if (!source.children || depth >= 8) return;
		console.log("Hi! I'm collapsing my children! " + source.name);

		/* Recursively call collapseChildren on all the expanded children of a node.*/
		for (var i = 0; i < source.children.length; i++) { 
			// console.log("About to call recursively.");
			// console.log("These are my children here: ");
			// console.log(source.children);
			// console.log("Here is my forced child");
			// console.log(childWithName(source.children[i]));
			console.log("Here is the child I would like to collapse");
			var child = forcedChildWithName(source.children[i]);
			console.log(child);
			console.log("Here are its children: ");
			console.log(child.children);
			if (child.children) {//children not already collapsed
				console.log("Here is the child I'm about to collapse");
				console.log(child);
				collapseChildren(source_master, child, duration, depth + 1);
			}
		}

		/* Calculate the new number of links that will be on the screen */
		var newL = l - source.children.length;
		var newN = n - source.children.length;

		/* A boolean to indicate whether the layout has been 
		   restarted */
		restarted = false; 

		/* Select the appropriate DOM elements one by 
		   one and collapse them */
		for (var i = 0; i < source.children.length; i++) { 
			if (!moreParentsOnScreen(source.children[i], source.name)) {//Consider replacing with a more efficient implementation of array.contains(?) (also keep an array of names of displayed/visible nodes) 
				/* Collapse the child nodes */
				svg.select("#" + source.children[i])
				   .transition()
				   .duration(duration)	
				   .attr("cx", source_master.x)
				   .attr("cy", source_master.y)
				   .attr("r", 1e-6)
				   // .style("opacity", 0.8)
				   .each("end", function () { 
				   	  	/* Remove child node from page */
						this.remove();

					   	/* Calculate the new number of nodes and links 
					      on the screen */
						l = svg.selectAll("line")[0].length;
				       	n = svg.selectAll("circle")[0].length;

				      	/* If all of the child links and nodes have been removed
				      	   restart the layout */
				      	if (newL == l && newN == n && !restarted) {

				      		restarted = true;
				      		restart();
				      	}
				   });

				/* Collapse the text label */
				svg.select("#" + source.children[i] + "t")
				   //.transition()
				   //.duration(duration)
				   //.attr("fill-opacity", 0)
				   .remove();

				/* Remove the child node from the set of nodes 
				   tracked by the force layout. */
				// console.log("Removing: ");
				// console.log(source.children[i]);
				force.nodes().splice(indexOfNode(source.children[i]), 1);
			}

			/* Collapse the child link */
			svg.select("#" + source.name + source.children[i])
				   .transition()
				   .duration(duration)
				   .attr("x1", source_master.x)
				   .attr("y1", source_master.y)
			       .attr("x2", source_master.x)
			       .attr("y2", source_master.y)
			       .style("opacity", 1e-6)
			       // .style("opacity", 0)
			   	   .each("end", function () { 
			   	  	 /* Remove child link from page */
					 this.remove();

				   	 /* Calculate the new number of nodes and links 
				       on the screen */
					 l = svg.selectAll("line")[0].length;
			       	 n = svg.selectAll("circle")[0].length;

			      	 /* If all of the child links and nodes have been removed
			      	    restart the layout */
			      	 if (newL == l && newN == n && !restarted) {
			      	 	restarted = true;	
			      	 	restart();
			      	 }
			   	   });

			/* Remove the link from the set of links 
			   tracked by the force layout. */
			force.links().splice(indexOfLink(source.name, source.children[i]), 1);

		}

		/* Set the children field to null, to indicated non-expanded children.*/
		source._children = source.children;
		source.children = false;

		/* Recolor source node.ss*/
		if (depth == 0) 
			svg.select("#" + source_master.name).style("fill", color);
	}

	/* Expand children; at this point: one level at a time. */
	var expandChildren = function expandChildren(source, duration) { 
		/* Calculate the new number of links that will be on the screen 
		   before layout-refresh */
		var newL = l;
		var newN = n;

		/* Initialize an array of all children who should be added to 
		   the nodes + links in the force layout after the nodes are 
		   drawn and removed from the page */
		var childNodes = [];
		var childLinks = [];

		/* Calculate positioning information for expanding nodes */
		var r = 90;
		var theta = 2 * Math.PI / source._children.length;

		restarted = false;

		/* Draw the children on the screen, on top of their parent */
	    var nodeEnter = svg.selectAll("circle")
					    .data(arrayOfChildren(source._children), function (d) {return d.name})
						.enter()
						.append("circle")
						.style("fill", color)
						.attr("r", 1e-6)
					    .attr("id", function(d) { return d.name })
					    .attr("class", "node")
					    .attr("cx", source.x)
					    .attr("cy", source.y)
					    .style("opacity", 1)
						.on("click", click)
						.call(force.drag);

		/* Draw links beginning and ending at their source. */
		var linkEnter = svg.selectAll("line")
						.data(arrayOfChildLinks(source, source._children), function (d) { 
							/* d3 is doing something weird here where some of the d.target/source attrs 
							   are objects and some are numbers (as per the array returned by the array 
							   ofChildLinks method). This if statement checks that dataset2.nodes[d.source/target]
							   is defined. */
							if (dataset2.nodes[d.source] && dataset2.nodes[d.target].name)
								return dataset2.nodes[d.source].name + dataset2.nodes[d.target].name;
						})
						.enter()
						.insert("line", ".node")
						.attr("r", node_radius)
				        .style("stroke", "#ccc")
				        .style("stroke-width", 1)
				        .style("opacity", 1e-6)
						.attr("id", function (d) { return dataset2.nodes[d.source].name + dataset2.nodes[d.target].name })
						.attr("x1", source.x)
						.attr("y1", source.y)
						.attr("x2", source.x)
						.attr("y2", source.y)
						.attr("marker-end", "url(#Triangle)");

		/* Expand nodes & links one by one */
		for (var i = 0; i < source._children.length; i++) {
			/* Check if  child exists on screen */
		    var child = forcedChildWithName(source._children[i]);

		    if (child) { //If it does, expand the appropriate link to it
				/* Expand link */
				svg.select("#" + source.name + source._children[i])
				   .transition()
				   .duration(duration)
				   .style("opacity", 0.6)
				   .attr("x2", function () { return child.x; })
				   .attr("y2", function () {
				   		childLinks.push({source: source, target: child});
					   	return child.y;
				   })
				   .each("end", function () { 
				   	 /* Remove this from the screen. Adding to the force layout (etc) 
				   	    has already been done above, in animating the nodes. */
				   	 this.remove();

			   	 	 /* Calculate the new number of nodes and links 
					    on the screen */
					 l = svg.selectAll("line")[0].length;
			      	 n = svg.selectAll("circle")[0].length;

				   	 if (newL == l && newN == n && !restarted) {
				   	 	restarted = true;
				      		/* Add all data for added child nodes to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childNodes.length; i++) 
								force.nodes().push(childNodes[i]);

				      		/* Add all data for add child links to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childLinks.length; i++)
				      			force.links().push(childLinks[i])

				      		/* Restart the force layout */
				      		restart();
				   	 }
				   });
		    } else { //If it doesn't, expand the node corresponding to it, along with the corresponding link
		    	child = childWithName(source._children[i]);

		    	toggleChildren(child);

		    	/* Expand child node */
				svg.select("#" + source._children[i])
				    .transition()
					.duration(duration)
					.attr("r", node_radius)
					.attr("cx", function () {
						child.x = source.x + r * Math.sin(theta * i);
						return child.px = source.x + r * Math.sin(theta * i);
					})
					.attr("cy", function () { 
						child.y = source.y + r * Math.cos(theta * i);
						child.py = child.y;
						/* Add the child node and link to the child nodes and links. */
			  			childNodes.push(child);
						childLinks.push({source: source, target: child});

					 	return source.y + r * Math.cos(theta * i);
					})	
					.style("opacity", 1)
					.each("end", function () { 
						/* Remove it from the screen */
						this.remove();

						/* Calculate the new number of nodes and links 
						   on the screen */
						l = svg.selectAll("line")[0].length;
				      	n = svg.selectAll("circle")[0].length;

				      	/* If all of the child links and nodes have been removed
				          restart the layout */
				      	if (newL == l && newN == n && !restarted) {
				      		// console.log("here!");
				      		restarted = true;
				      		/* Add all data for added child nodes to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childNodes.length; i++) 
								force.nodes().push(childNodes[i]);

				      		/* Add all data for add child links to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childLinks.length; i++)
				      			force.links().push(childLinks[i])

				      		/* Restart the force layout */
				      		restart();
				      	}
					});

				/* Expand link */
				svg.select("#" + source.name + source._children[i])
				   .transition()
				   .duration(duration)
				   .style("opacity", 0.6)
				   .attr("x2", function () { return source.x + r * Math.sin(theta * i) })
				   .attr("y2", function () { 
				   	/* Link has already been added (to the set tracked by the force 
				   	   layout when adding nodes above) */
				   	return source.y + r * Math.cos(theta * i);
				   })
				   .each("end", function () { 
				   	 /* Remove this from the screen. Adding to the force layout (etc) 
				   	    has already been done above, in animating the nodes. */
				   	 this.remove();

			   	 	 /* Calculate the new number of nodes and links 
					    on the screen */
					 l = svg.selectAll("line")[0].length;
			      	 n = svg.selectAll("circle")[0].length;

				   	 if (newL == l && newN == n && !restarted) {
				   	 	restarted = true;
				      		/* Add all data for added child nodes to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childNodes.length; i++) 
								force.nodes().push(childNodes[i]);

				      		/* Add all data for add child links to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childLinks.length; i++)
				      			force.links().push(childLinks[i])

				      		/* Restart the force layout */
				      		restart();
				   	 }
				   });
		    }
		}

		source.children = source._children;

		source._children = false;

		svg.select("#" + source.name).style("fill", color);

		/* Add the node and link to the arrays used to join this data 
		   to the set of nodes and links tracked by the force layout */
		// childNodes.push(childWithName(source._children[i]));
		// childLinks.push({source: source, target: childWithName(source._children[i])});
	}

	/* Define what happens to a node on a click event */
	var click = function click(source) { 
		/* Prevent double clicks */
		var current_time = (new Date).getTime(); //number of milliseconds since Jan 1, 1970
		if (current_time - last_click < single_click_timeout){
			console.log("click prevented!");
			return;
		}
		if (d3.event.defaultPrevented) return; 

		/* Select a duration. */
		var duration = d3.event && d3.event.altKey ? 5000 : 500;

		/* Calculate the number of links and nodes on the screen. */
		l = svg.selectAll("line")[0].length;
		n = svg.selectAll("circle")[0].length;

		/* Fix all the nodes in the layout, so as to allow for smooth 
		   collapse and expansion. Note: Nodes will be unfixed in the 
		   restart function. */
 		for (var i = 0; i < force.nodes().length; i++) { 
	 		force.nodes()[i].fixed = true;
		}

		/* Collapse children. */
		if (source.children && source.children.length > 0) { 
			// console.log("I have these children");
			// console.log(source.children);
			// console.log("And these parents!");
			// console.log(source.parents);
			collapseChildren(source, source, duration, 0);
		/* Expand children */
		} else if (source._children && source._children.length > 0) { //If children collapsed
			// console.log("My children are collapsed, but here they are!");
			expandChildren(source, duration);
		} else { 
			restart();
			// console.log("no children!");
		}
		// console.log("*********************************************");
		last_click = current_time;
		// console.log("Here is the current dataset: ");
		// console.log(dataset);
	};

	function main() { 
		// console.log("just before!");
	    nodes2 = dataset2.nodes; 
		links2 = dataset2.links;

		/* Start the force layout */
		force = d3.layout.force()
							 .nodes(dataset.nodes)
							 .links(dataset.links)
							 .size([w, h])
		                     .linkDistance([90])
		                     .charge([-2000])   
							 .on("tick", tick)
							 .start();

		/* Define the triangle marker. */
		svg.append("defs").selectAll("marker")
		   .data(["Triangle"])
		   .enter()
		   .append("marker")
		   .attr("id", function (d) {return d})
		   .attr("viewBox", "0 -5 10 10")
		   .attr("refX", refX)
		   .attr("refY", refY)
		   .attr("markerWidth", markerHeight)
		   .attr("markerHeight", markerWidth)
		   .attr("orient", "auto")
		   .append("path")
		   .attr("d", path);

		/* Put all the links on the canvas */
		links = svg.selectAll("line")
	        .data(dataset.links, function (d) { return d.source.name + d.target.name })
	        .enter() 
	        .insert("line", ".node")
	        .style("stroke", "#ccc")
	        .style("stroke-width", 1)
	        .attr("id", function (d) { return d.source.name + d.target.name  } )
	        .attr("marker-end", "url(#Triangle)");

	    /* Put all the nodes on the canvas */
		nodes = svg.selectAll("circle")
	        .data(dataset.nodes, function (d) {return d.name})
	        .enter()
	        .append("circle")
	        .style("fill", color)
	        .attr("r", node_radius)
	        .attr("id", function(d) {return d.name})
	        .attr("class", "node")
	        .on("click", click)
	        .call(force.drag);

	    text = svg.append("g").selectAll("text")
				    .data(force.nodes(), function (d) { return d.name + "t"})
				   .enter().append("text")
				    .attr("x", -5)
				    .attr("y", "2em")
				    .attr("id", function (d) { return d.name + "t" })
				    .text(function(d) { return d.name; });

	    /* Calculate the number of links and nodes 
	       on the string. */
	    l = links[0].length;
	   	n = nodes[0].length;
	}

	/* Return the coloring for a node. */
	var color = function color(d) { 
		if (d.children && d.children.length > 0) 
			return colorscheme1 ? "#c6dbef" : colorscheme2 ? "#fff" : "#000"; //children_expanded_color();
		else if (d._children && d._children.length > 0)
			return colorscheme1 ? "#3182bd" : colorscheme2 ? "lightsteelblue" : "#000"; //children_collapsed_color(); 
		else 
			return colorscheme1 ? "#fd8d3c" : colorscheme2 ? "#fff" : "#000"  //no_children_color();
	}

	/* Checks whether the node nominated for collapse has more parents on screen than the 
	   parent which is requesting its collapse. Takes the names of the parent and the child 
	   it is nominating for collapse. Note that a node is only considered a parent if it is 
	   taking ownership (pointing) to its child on the screen. 
	 */
	var moreParentsOnScreen = function moreParentsOnScreen (childName, parentName) { 
		var child = childWithName(childName);

		if (!child) { 
			return false;
		}
		for (var i = 0; i < child.parents.length; i++) {
			var parent = forcedChildWithName(child.parents[i]);
			if (parent && parent.name != parentName && parent.children) { 
				return true;
			}
		}
		return false;
	}

	/* Toggles the children of a given node. */
	function toggleChildren (source) { 
		if (source.children) { 
			source._children = source.children;
			source.children = false;
		} else { 
			source.children = source._children; 
			source._children = false;
		}
	}

	/* Sleep function */
	function sleep(millis, callback) { 
		setTimeout(function() 
			{ callback(); }, 
		millis);
	}

</script>
</body>