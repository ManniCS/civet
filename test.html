<!DOCTYPE html>
<meta charset="utf-8">
<link type="text/css" rel="stylesheet" href="style.css"/>
<style type="text/css">

body { 
	  background: url(texture-noise.png);
	  overflow: hidden;
	  margin: 0;
	  font-size: 14px;
	  font-family: "Helvetica Neue", Helvetica;
}

node:hover {
  color: #666;
}

.node {
  cursor: pointer;
  stroke: #3182bd;
  stroke-width: 3px;
}

.node text {
  font-size: 11px;
}

path.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>
<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

	/** Setting up variables. **/
	var w = 1500,
	    h = 750,
	    colorscheme1 = true,
	    colorscheme2 = colorscheme1 ? false : true,
	    node_radius = colorscheme1 ? 15 : colorscheme2 ? 10 : 10, 
	    refX = colorscheme1 ? 25 : colorscheme2 ? 23 : 23, 
	    refY = colorscheme1 ? 0 : colorscheme2 ? 0 : 0, 
	    markerHeight = colorscheme1 ? 11 : colorscheme2 ? 8 : 8, 
	    markerWidth = colorscheme1 ? 11 : colorscheme2 ? 8 : 8, 
	    path = colorscheme1 ? "M0,-3L10,0L0,3" : colorscheme2 ? "M0,-4L10,0L0,4" : "M0,-4L10,0L0,4", //path for marker
	    single_click_timeout = 500;

	var svg = d3.select("body").append("svg")
	    .attr("height", h)
	    .attr("width", w);

	/* Declare variables that will be used globally later in the script. */
	var force, //variable for force layout
	    l, n, //Calculate the number of links and nodes on the string. 
        nodes2, links2, //Set of nodes and links in the original dataset
	    restarted, //Variable to indicated whether the layout has been restarted yet
	    last_click = (new Date).getTime(); //Variable to record the last_click on the dom

	/* The set of all d3 elements on the screen 
	 (and data bound to them.) */
	var links = svg.selectAll("line"),
		nodes = svg.selectAll("circle"),
		text = svg.selectAll("text"); //labels

	/* Define the dataset */
	var dataset = {}; //the dataset of reduced nodes
	var dataset2 = {}; //the primary dataset

	dataset = {"nodes": [
				{"parents": ["STViewController"], "name": "STDisplayManager_iPhone", "children": ["STViewControllerFactoryCollection", "STUser", "STConstants", "STLoginViewController_iPhone"]},
				{"parents": ["STDisplayManager_iPhone", "STViewController"], "name": "STViewControllerFactoryCollection", "children": ["STGroupViewControllerFactory", "STMessageViewControllerFactory", "STInitializationViewControllerFactory"]},
				{"parents": ["STDisplayManager_iPhone", "STSaveProfileOperation", "STRemoveGroupMembersOperation", "STChangeColleagueBlockStatusOperation"], "name": "STUser", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STConstants", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STLoginViewController_iPhone", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STGroupViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STMessageViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STInitializationViewControllerFactory", "children": []
				},
				{"parents": [], "name": "STViewController", "children": ["STDisplayManager_iPhone", "STViewControllerFactoryCollection"]},
				{"parents": [], "name": "STSaveProfileOperation", "children": ["STUser"]},
				{"parents": [], "name": "STRemoveGroupMembersOperation", "children": ["STUser"]},
				{"parents": [], "name": "STChangeColleagueBlockStatusOperation", "children": ["STUser"]}],
				"links": [
				{"source": 0, "target": 1},
				{"source": 0, "target": 2},
				{"source": 0, "target": 3},
				{"source": 0, "target": 4},
				{"source": 1, "target": 5},
				{"source": 1, "target": 6},
				{"source": 1, "target": 7},
				{"source": 8, "target": 0},
				{"source": 8, "target": 1},
				{"source": 9, "target": 2},
				{"source": 10, "target": 2},
				{"source": 11, "target": 2}]};

	dataset2 = {"nodes": [
				{"parents": ["STViewController"], "name": "STDisplayManager_iPhone", "children": ["STViewControllerFactoryCollection", "STUser", "STConstants", "STLoginViewController_iPhone"]},
				{"parents": ["STDisplayManager_iPhone", "STViewController"], "name": "STViewControllerFactoryCollection", "children": ["STGroupViewControllerFactory", "STMessageViewControllerFactory", "STInitializationViewControllerFactory"]},
				{"parents": ["STDisplayManager_iPhone", "STSaveProfileOperation", "STRemoveGroupMembersOperation", "STChangeColleagueBlockStatusOperation"], "name": "STUser", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STConstants", "children": []},
				{"parents": ["STDisplayManager_iPhone"], "name": "STLoginViewController_iPhone", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STGroupViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STMessageViewControllerFactory", "children": []},
				{"parents": ["STViewControllerFactoryCollection"], "name": "STInitializationViewControllerFactory", "children": []
				},
				{"parents": [], "name": "STViewController", "children": ["STDisplayManager_iPhone", "STViewControllerFactoryCollection"]},
				{"parents": [], "name": "STSaveProfileOperation", "children": ["STUser"]},
				{"parents": [], "name": "STRemoveGroupMembersOperation", "children": ["STUser"]},
				{"parents": [], "name": "STChangeColleagueBlockStatusOperation", "children": ["STUser"]}],
				"links": [
				{"source": 0, "target": 1},
				{"source": 0, "target": 2},
				{"source": 0, "target": 3},
				{"source": 0, "target": 4},
				{"source": 1, "target": 5},
				{"source": 1, "target": 6},
				{"source": 1, "target": 7},
				{"source": 8, "target": 0},
				{"source": 8, "target": 1},
				{"source": 9, "target": 2},
				{"source": 10, "target": 2},
				{"source": 11, "target": 2}]};

	/* Inject a 3 second delay before running the code for the main functioning of the program
	   to allow the browser to load the information from the local files into the javascript 
	   variables for the graph information.*This is janky. Find a way to fix it.* */
	sleep(10, main);

	/** Define functions for use in the script. **/

	/* Returns an array of the objects corresponding 
	   to a particular node's children, accepting a 
	   list of their names. */
	var arrayOfChildren = function arrayOfChildren(children) {
		var array = [];
		for (var i = 0; i < dataset2.nodes.length; i++) { 
			for (var j = 0; j < children.length; j++) { //consider replacing with jQuery .contains(?)
				if (dataset2.nodes[i].name == children[j]) 
					array.push(dataset2.nodes[i]);
			}
		}
		return array;
	}

	/* Returns an array of the objects corresponding to a particular 
	   node's child links, accepting the node obj, and a list of their 
	   names. */
	var arrayOfChildLinks = function arrayOfChildLinks (source, children) { 
		var array = [];
		for (var i = 0; i < dataset2.links.length; i++) { 
			for (var j = 0; j < children.length; j++) { 
				/* Cannot be handled as links in the array tracked by the 
				   force layout as target and source are not populated with 
				   their corresponding objects. */
				var sourceName = dataset2.nodes[dataset2.links[i].source].name;
				var targetName = dataset2.nodes[dataset2.links[i].target].name;
				if (sourceName == source.name && targetName == children[j]) { 
						array.push(dataset2.links[i]);
				}
			}
		}
		return array;
	}

	/* Returns the child-object from the original 
	   dataset corresponding to a particular name. */
	var childWithName = function childWithName(name) { 
		for (var i = 0; i < nodes2.length; i++) { 
			if (nodes2[i].name == name) { 
				return dataset2.nodes[i];
			}
		}
		return false;
	}

	/* Returns the force-layout tracked object 
	   corresponding to a particular name. */
	var forcedChildWithName = function forcedChildWithName(name) { 
		for (var i = 0; i < dataset.nodes.length; i++) { 
			if (dataset.nodes[i].name == name) {
				return dataset.nodes[i];
			}
		} 
		return false;
	}

	/* Returns the equivalent degree value in radians. */
	var degToRad = function degToRad (degrees) { 
		return degrees * (Math.PI / 180);
	}

	/* Restarts the force layout based on the nodes and links it tracks 
       and binds those nodes + links to the screen. */
	var restart = function restart() {
	  links = links.data(force.links(), function(d) { return d.source.name + d.target.name });
	  links.enter().insert("line", ".node")
	  			   .attr("id", function (d) { return d.source.name + d.target.name })
	  			   .style("stroke", "#ccc")
				   .style("stroke-width", 1)
				   .attr("marker-end", "url(#Triangle)");
	  links.exit().remove();

	  nodes = nodes.data(force.nodes(), function(d) { return d.name });
	  nodes.enter().append("circle")
	  			   .style("fill", color)
	  			   .attr("r", node_radius)
	  			   .attr("id", function(d) { return d.name })
	  			   .attr("class", "node")
	  			   .on("click", click)
	  			   .call(force.drag);
	  nodes.exit().remove();

	  text = text.data(force.nodes(), function (d) { return d.name + "t"});
	  text.enter().append("text")
	  			  .attr("x", -5)
				  .attr("y", "2em")
				  .attr("id", function (d) { return d.name + "t" })
				  .text(function(d) { return d.name; });

	  force.start();
	  
	  /* Unfix the nodes */
	  for (var i = 0; i < force.nodes().length; i++) { 
	  	  force.nodes()[i].fixed = false;
	  }
	}

	/* Returns the index of the node with the given 
	   name.  */
	var indexOfNode = function indexOfNode (name) { 
		for (var i = 0; i < dataset.nodes.length; i++) { 
			if (dataset.nodes[i].name == name)
				return i;
		}
		return -1;
	}

	/* Returns the index of the link matching the 
	   given names of the source and target. */
	var indexOfLink = function indexOfLink (source, target) { 
		for (var i = 0; i < dataset.links.length; i++) { 
			if (dataset.links[i].source.name == source &&
				 dataset.links[i].target.name == target)
				return i;
		}
	}

	/* Updates all of the links and nodes associated with a 
	   force directed layout based on the properties computed 
	   for these nodes + links by the layout. */
	var tick = function tick() {
		links.attr("x1", function(d) { return d.source.x; })
		     .attr("y1", function(d) { return d.source.y; })
		     .attr("x2", function(d) { return d.target.x; })
		     .attr("y2", function(d) { return d.target.y; });

		nodes.attr("cx", function(d) { return d.x; })
		     .attr("cy", function(d) { return d.y; });

		text.attr("transform", transform);
	}

	/* */
	var transform = function (d) {
		return "translate(" + d.x + "," + d.y +")";
	}

	/* Recursively call collapse children on all of source's expanded children */
	var collapseChildren = function collapseChildren(source_master, source, duration, depth) { 
		console.log("I am now collapsing children for: ");
		console.log(source.name);

		/* Base case */
		if (!source.children || depth >= 8) return;

		/* Recursively call collapseChildren on all the expanded children of a node.*/
		for (var i = 0; i < source.children.length; i++) { 
			var child = forcedChildWithName(source.children[i]);
			if (!moreSuperiorParentsOnScreen(child.name, source_master.name) && child.children) {//children not already collapsed and does not have any owning children still on screen
				collapseChildren(source_master, child, duration, depth + 1);
			}
		}

		/* Calculate the new number of links that will be on the screen */
		var newL = l - source.children.length;
		var newN = n - source.children.length;

		/* A boolean to indicate whether the layout has been 
		   restarted */
		restarted = false; 

		/* Select the appropriate DOM elements one by 
		   one and collapse them */
		for (var i = 0; i < source.children.length; i++) { 
			if (moreSuperiorParentsOnScreen(source.children[i], source.name)) { 
				newN++; //increase the new number of nodes the framework is expecting to appear
						//on the screen to adjust for nodes that won't actually be contracted
			} else {//Consider replacing with a more efficient implementation of array.contains(?) (also keep an array of names of displayed/visible nodes) 
				/* Collapse the child nodes */
				svg.select("#" + source.children[i])
				   .transition()
				   .duration(duration)	
				   .attr("cx", source_master.x)
				   .attr("cy", source_master.y)
				   .attr("r", 1e-6)
				   .each("end", function () { 
				   	  	/* Remove child node from page */
						this.remove();

					   	/* Calculate the new number of nodes and links 
					      on the screen */
						l = svg.selectAll("line")[0].length;
				       	n = svg.selectAll("circle")[0].length;

				      	/* If all of the child links and nodes have been removed
				      	   restart the layout */
				      	if (newL == l && newN == n && !restarted) {

				      		restarted = true;
				      		restart();
				      	}
				   });

				/* Collapse the text label */
				svg.select("#" + source.children[i] + "t")
				   .remove();

				/* Remove the child node from the set of nodes 
				   tracked by the force layout. */
				force.nodes().splice(indexOfNode(source.children[i]), 1);
			}

			/* Collapse the child link */
			svg.select("#" + source.name + source.children[i])
				   .transition()
				   .duration(duration)
				   .attr("x1", source_master.x)
				   .attr("y1", source_master.y)
			       .attr("x2", source_master.x)
			       .attr("y2", source_master.y)
			       .style("opacity", 1e-6)
			   	   .each("end", function () { 
			   	  	 /* Remove child link from page */
					 this.remove();

				   	 /* Calculate the new number of nodes and links 
				       on the screen */
					 l = svg.selectAll("line")[0].length;
			       	 n = svg.selectAll("circle")[0].length;

			      	 /* If all of the child links and nodes have been removed
			      	    restart the layout */
			      	 if (newL == l && newN == n && !restarted) {
			      	 	restarted = true;	
			      	 	restart();
			      	 }
			   	   });

			/* Remove the link from the set of links 
			   tracked by the force layout. */
			force.links().splice(indexOfLink(source.name, source.children[i]), 1);

		}

		/* Set the children field to null, to indicated non-expanded children.*/
		source._children = source.children;
		source.children = false;

		/* Recolor source to indicate collapsed children. */
		svg.selectAll("#" + source.name)
		   .style("fill", color);

		/* Recolor source node.ss*/
		if (depth == 0) 
			svg.select("#" + source_master.name).style("fill", color);
	}

	/* Expand children; at this point: one level at a time. */
	var expandChildren = function expandChildren(source, duration) { 
		/* Calculate the new number of links that will be on the screen 
		   before layout-refresh */
		var newL = l;
		var newN = n;

		/* Initialize an array of all children who should be added to 
		   the nodes + links in the force layout after the nodes are 
		   drawn and removed from the page */
		var childNodes = [];
		var childLinks = [];

		/* Calculate positioning information for expanding nodes */
		var r = 90;
		var theta = 2 * Math.PI / source._children.length;

		restarted = false;

		/* Draw the children on the screen, on top of their parent */
	    var nodeEnter = svg.selectAll("circle")
					    .data(arrayOfChildren(source._children), function (d) {return d.name})
						.enter()
						.append("circle")
						.style("fill", color)
						.attr("r", 1e-6)
					    .attr("id", function(d) { return d.name })
					    .attr("class", "node")
					    .attr("cx", source.x)
					    .attr("cy", source.y)
					    .style("opacity", 1)
						.on("click", click)
						.call(force.drag);

		/* Draw links beginning and ending at their source. */
		var linkEnter = svg.selectAll("line")
						.data(arrayOfChildLinks(source, source._children), function (d) { 
							/* d3 is doing something weird here where some of the d.target/source attrs 
							   are objects and some are numbers (as per the array returned by the array 
							   ofChildLinks method). This if statement checks that dataset2.nodes[d.source/target]
							   is defined. */
							if (dataset2.nodes[d.source] && dataset2.nodes[d.target].name)
								return dataset2.nodes[d.source].name + dataset2.nodes[d.target].name;
						})
						.enter()
						.insert("line", ".node")
						.attr("r", node_radius)
				        .style("stroke", "#ccc")
				        .style("stroke-width", 1)
				        .style("opacity", 1e-6)
						.attr("id", function (d) { return dataset2.nodes[d.source].name + dataset2.nodes[d.target].name })
						.attr("x1", source.x)
						.attr("y1", source.y)
						.attr("x2", source.x)
						.attr("y2", source.y)
						.attr("marker-end", "url(#Triangle)");

		/* Expand nodes & links one by one */
		for (var i = 0; i < source._children.length; i++) {
			/* Check if  child exists on screen */
		    var child = forcedChildWithName(source._children[i]);

		    if (child) { //If it does, expand the appropriate link to it
		   	console.log("Here's the child!");
		   	console.log(child);

				/* Expand link */
				svg.select("#" + source.name + source._children[i])
				   .transition()
				   .duration(duration)
				   .style("opacity", 0.6)
				   .attr("x2", function () { return child.x; })
				   .attr("y2", function () {
				   		childLinks.push({source: source, target: child});
					   	return child.y;
				   })
				   .each("end", function () { 
				   	 /* Remove this from the screen. Adding to the force layout (etc) 
				   	    has already been done above, in animating the nodes. */
				   	 this.remove();

			   	 	 /* Calculate the new number of nodes and links 
					    on the screen */
					 l = svg.selectAll("line")[0].length;
			      	 n = svg.selectAll("circle")[0].length;

				   	 if (newL == l && newN == n && !restarted) {
				   	 	restarted = true;
				      		/* Add all data for added child nodes to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childNodes.length; i++) 
								force.nodes().push(childNodes[i]);

				      		/* Add all data for add child links to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childLinks.length; i++)
				      			force.links().push(childLinks[i])

				      		/* Restart the force layout */
				      		restart();
				   	 }
				   });
		    } else { //If it doesn't, expand the node corresponding to it, along with the corresponding link
		    	child = childWithName(source._children[i]); 

		    	setChildrenAsCollapsed(child);

		    	/* Expand child node */
				svg.select("#" + source._children[i])
				    .transition()
					.duration(duration)
					.attr("r", node_radius)
					.attr("cx", function () {
						child.x = source.x + r * Math.sin(theta * i);
						return child.px = source.x + r * Math.sin(theta * i);
					})
					.attr("cy", function () { 
						child.y = source.y + r * Math.cos(theta * i);
						child.py = child.y;
						/* Add the child node and link to the child nodes and links. */
			  			childNodes.push(child);
						childLinks.push({source: source, target: child});

					 	return source.y + r * Math.cos(theta * i);
					})	
					.style("opacity", 1)
					.each("end", function () { 
						/* Remove it from the screen */
						this.remove();

						/* Calculate the new number of nodes and links 
						   on the screen */
						l = svg.selectAll("line")[0].length;
				      	n = svg.selectAll("circle")[0].length;

				      	/* If all of the child links and nodes have been removed
				          restart the layout */
				      	if (newL == l && newN == n && !restarted) {
				      		restarted = true;
				      		/* Add all data for added child nodes to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childNodes.length; i++) 
								force.nodes().push(childNodes[i]);

				      		/* Add all data for add child links to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childLinks.length; i++)
				      			force.links().push(childLinks[i])

				      		/* Restart the force layout */
				      		restart();
				      	}
					});

				/* Expand link */
				svg.select("#" + source.name + source._children[i])
				   .transition()
				   .duration(duration)
				   .style("opacity", 0.6)
				   .attr("x2", function () { return source.x + r * Math.sin(theta * i) })
				   .attr("y2", function () { 
				   	/* Link has already been added (to the set tracked by the force 
				   	   layout when adding nodes above) */
				   	return source.y + r * Math.cos(theta * i);
				   })
				   .each("end", function () { 
				   	 /* Remove this from the screen. Adding to the force layout (etc) 
				   	    has already been done above, in animating the nodes. */
				   	 this.remove();

			   	 	 /* Calculate the new number of nodes and links 
					    on the screen */
					 l = svg.selectAll("line")[0].length;
			      	 n = svg.selectAll("circle")[0].length;

				   	 if (newL == l && newN == n && !restarted) {
				   	 	restarted = true;
				      		/* Add all data for added child nodes to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childNodes.length; i++) 
								force.nodes().push(childNodes[i]);

				      		/* Add all data for add child links to set 
				      		   tracked by the force layout */
				      		for (var i = 0; i < childLinks.length; i++)
				      			force.links().push(childLinks[i])

				      		/* Restart the force layout */
				      		restart();
				   	 }
				   });
		    }
		}

		source.children = source._children;

		source._children = false;

		svg.select("#" + source.name).style("fill", color);

		/* Add the node and link to the arrays used to join this data 
		   to the set of nodes and links tracked by the force layout */
	    // ...
	}

	/* Define what happens to a node on a click event */
	var click = function click(source) { 
		console.log("Hey");
		console.log("Here I am:");
		console.log(source);

		/* Prevent double clicks */
		var current_time = (new Date).getTime(); //number of milliseconds since Jan 1, 1970
		if (current_time - last_click < single_click_timeout){
			console.log("click prevented!");
			return;
		}
		if (d3.event.defaultPrevented) return; 

		/* Select a duration. */
		var duration = d3.event && d3.event.altKey ? 5000 : 500;

		/* Calculate the number of links and nodes on the screen. */
		l = svg.selectAll("line")[0].length;
		n = svg.selectAll("circle")[0].length;

		/* Fix all the nodes in the layout, so as to allow for smooth 
		   collapse and expansion. Note: Nodes will be unfixed in the 
		   restart function. */
 		for (var i = 0; i < force.nodes().length; i++) { 
	 		force.nodes()[i].fixed = true;
		}

		/* Collapse children. */
		if (source.children && source.children.length > 0) { 
			collapseChildren(source, source, duration, 0);
		/* Expand children */
		} else if (source._children && source._children.length > 0) { //If children collapsed
			expandChildren(source, duration);
		} else { 
			restart();
		}
		last_click = current_time;
	};

	function main() { 
	    nodes2 = dataset2.nodes; 
		links2 = dataset2.links;

		/* Start the force layout */
		force = d3.layout.force()
							 .nodes(dataset.nodes)
							 .links(dataset.links)
							 .size([w, h])
		                     .linkDistance([90])
		                     .charge([-2000])   
							 .on("tick", tick)
							 .start();

		/* Define the triangle marker. */
		svg.append("defs").selectAll("marker")
		   .data(["Triangle"])
		   .enter()
		   .append("marker")
		   .attr("id", function (d) {return d})
		   .attr("viewBox", "0 -5 10 10")
		   .attr("refX", refX)
		   .attr("refY", refY)
		   .attr("markerWidth", markerHeight)
		   .attr("markerHeight", markerWidth)
		   .attr("orient", "auto")
		   .append("path")
		   .attr("d", path);

		/* Put all the links on the canvas */
		links = svg.selectAll("line")
	        .data(dataset.links, function (d) { return d.source.name + d.target.name })
	        .enter() 
	        .insert("line", ".node")
	        .style("stroke", "#ccc")
	        .style("stroke-width", 1)
	        .attr("id", function (d) { return d.source.name + d.target.name  } )
	        .attr("marker-end", "url(#Triangle)");

	    /* Put all the nodes on the canvas */
		nodes = svg.selectAll("circle")
	        .data(dataset.nodes, function (d) {return d.name})
	        .enter()
	        .append("circle")
	        .style("fill", color)
	        .attr("r", node_radius)
	        .attr("id", function(d) {return d.name})
	        .attr("class", "node")
	        .on("click", click)
	        .call(force.drag);

	    text = svg.append("g").selectAll("text")
				    .data(force.nodes(), function (d) { return d.name + "t"})
				   .enter().append("text")
				    .attr("x", -5)
				    .attr("y", "2em")
				    .attr("id", function (d) { return d.name + "t" })
				    .text(function(d) { return d.name; });

	    /* Calculate the number of links and nodes 
	       on the string. */
	    l = links[0].length;
	   	n = nodes[0].length;
	}

	/* Return the coloring for a node. */
	var color = function color(d) { 
		if (d.children && d.children.length > 0) 
			return colorscheme1 ? "#c6dbef" : colorscheme2 ? "#fff" : "#000"; //children_expanded_color();
		else if (d._children && d._children.length > 0)
			return colorscheme1 ? "#3182bd" : colorscheme2 ? "lightsteelblue" : "#000"; //children_collapsed_color(); 
		else 
			return colorscheme1 ? "#fd8d3c" : colorscheme2 ? "#fff" : "#000"  //no_children_color();
	}

	/* A superior parent relationship is one that is defined between a node, its child, and 
	   another parent of the child. Note that this means the child must have at least two parents. 
	   A node is a superior parent of its child if it is not, itself, a progeny of the other parent 
	   in question. This function determines if there are any superior parents of a child (with respect
	   to another parent, whose name is passed as the second argument.)
	 */
	var moreSuperiorParentsOnScreen = function moreSuperiorParentsOnScreen (childName, parentName) {
		var child = childWithName(childName);
		var noParentsOnScreen = true;
		console.log("***");
		console.log("Checking for ");
		console.log(child);
		console.log("Ignoring");
		console.log(parentName);

		if (!child) //second and third checks represent the base case(s) of finding  
			return false;//no parent other than the node originally causing the collapse

		for (var i = 0; i < child.parents.length; i++) {
			var parent = forcedChildWithName(child.parents[i]);
			if (parent && parent.name != parentName && parent.children   //check parent is not collapsed and that it has parents
					&& moreSuperiorParentsOnScreen(parent.name, parentName)) {   //other than the original parent causing the collapse
				console.log("Hey, I found a parent for " + childName + "!");
				console.log(parent);

				console.log("Here's the parent name I was ignoring: " + parentName);
				console.log("Here's the name of the parent I found: " + parent.name); 
				return true;
			}
			if (parent) noParentsOnScreen = false; //if found a parent at all, keep track
		}

		if (noParentsOnScreen) {//Implies the parent whose name is passed as the second parameter
			console.log("Found no parents on screen for " + childName + "!");
			return true;       //cannot be reached from the original node (vacuous truth)
		} else {
			console.log("Found no more parents on screen than specified one for " + childName + "!");
			return false;
		}	
	}

	/* Sets children as collapsed. */
	var setChildrenAsCollapsed = function setChildrenAsCollapsed (source) { 
		if (!source._children)
			source._children = source.children;
		source.children = false;
	}

	// /* Toggles the children of a given node. */
	// function toggleChildren (source) { 
	// 	if (source.children) { 
	// 		source._children = source.children;
	// 		source.children = false;
	// 	} else { 
	// 		source.children = source._children; 
	// 		source._children = false;
	// 	}
	// }

	/* Sleep function */
	function sleep(millis, callback) { 
		setTimeout(function() 
			{ callback(); }, 
		millis);
	}

</script>
</body>